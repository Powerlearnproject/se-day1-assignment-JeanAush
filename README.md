[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18391778&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

# Part 1: Introduction to Software Engineering

## Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the process of giving instructions called code to a computer to execute, to be able to solve real world problems. 
### Importance of software engineering
1. Solving real world problems. A software engineer solves real world problems by creating and executing code
2. Secure and Quality. Software systems created by software engineers are secure and of good quality

## Identify and describe at least three key milestones in the evolution of software engineering.
1. The Birth of Structured Programming. This represented the first major paradigm shift in how software was designed and written. Before structured programming, code was often unorganized and difficult to maintain. Control structures, the waterfall model and C programming language was introduced.

2. The Agile Revolution. This milestone represented a complete rethinking of the software development process, emphasizing adaptability, collaboration, and delivering working software quickly.

3. DevOps and Continuous Delivery. This milestone dramatically reduced the time from idea to production, allowing organizations to deploy code hundreds of times per day while maintaining quality and reliability.


## List and briefly explain the phases of the Software Development Life Cycle.
1. Planning & Requirements Gathering. This is where the project scope and objectivs are defined, and a feasibility study is conducted.
2. Analysis & Design. Analysis and documention of detailed functional and non-functional requirements is done to come up with software specifications, and the system architecture design is done in this phase.
3. Implementation. This is the coding part where we write structured code for the system following standard guidelines for best practice and system specifications
4. Testing.We test the code to ensure it performs the intended tasks and check for faults and correct them.
5. Deployment. We deploy so that the system can be available for use 
6. Maintenance. We maintain the system for upgrades and updates


## Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. The waterfall model each phase must be completed before the next begins while the agile model is iterative and incremental in development in short cycles.
2. The waterfall model has fixed requirements at the beginning while the agile method has evolving requirements throughout.
3. The customer involvement in the waterfall model is heavy at the beginning and limited after, while in agile there is contiuous customer involment throughout.
4. The product for the waterfall model is only complete at the end while the agile method has a working software after each iteration.
5. Testing is done after the development phase in the waterfall model while testing is done throughout the process.


## Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer- Is responsible for writing code, testing and deploying the code to make sure it functions as intended.
Quality Assurance Engineer -  Responsible for ensuring the software meets quality standards before reaching users.
Project Manager - Coordinate the entire software development phase.


## Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs like Visual Studio Code and Eclipse provide a comprehensive environment for coding, debugging, and testing, while VCS like Git and SVN help manage code changes and collaborate effectively.


## What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Common Problems                     Strategies to Overcome
1. Meeting Deadlines                1. Effective Time Management
2. Managing Complexity              2. Modular Design
3. Ensuring code Quality            3. Thorough Testing


## Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing - Verifying the functionality of individual units of code, typically functions or methods. Importance - Early detection of bugs, improved code maintainability, and easier debugging.
Integration Testing - Testing the interactions between different units of code, ensuring they work together seamlessly. Importance - Ensuring smooth integration of modules, reducing the risk of unexpected behavior, and validating system architecture. 
System Testing -  Testing the entire software system as a whole, simulating real-world scenarios and user interactions. Importance - Assessing the system's overall functionality, identifying performance bottlenecks, and ensuring it meets user expectations.
Acceptance Testing - Verifying that the software meets the requirements and expectations of the end-users. Importance -  Gaining user acceptance, reducing the risk of rework, and ensuring a successful software release.

# Part 2: Introduction to AI and Prompt Engineering
## Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the art of crafting effective prompts for AI models. It involves understanding the model's capabilities and limitations, and crafting clear, specific, and concise prompts that guide the model to generate the desired output.

## Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
A vague prompt could be "Write a story."  A more effective prompt could be "Write a short story about a young girl who discovers a magical portal in her backyard." The improved prompt is more effective because it provides context, specifies the target audience, and sets clear expectations for the AI model.

